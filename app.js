// === Atlantis NAS — app.js (RTDB version) ===
// Realtime Database (RTDB) migration of folder/file metadata.
// Keep Storage for file binaries.

import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
import {
  getAuth,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
import {
  getDatabase,
  ref,
  push,
  set,
  onValue,
  dbGet,
  query,
  orderByChild,
  equalTo,
  update,
  remove,
  runTransaction,
  serverTimestamp,
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";
import {
  getStorage,
  ref as storageRef,
  uploadBytesResumable,
  getDownloadURL,
  deleteObject,
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-storage.js";

// --- Firebase config: ganti kalau perlu ---
const firebaseConfig = {
  apiKey: "AIzaSyBdKELW2FNsL7H1zB8R765czcDPaSYybdg",
  authDomain: "atlantis-store.firebaseapp.com",
  databaseURL: "https://atlantis-store-default-rtdb.firebaseio.com",
  projectId: "atlantis-store",
  storageBucket: "atlantis-store.appspot.com",
  messagingSenderId: "566295949160",
  appId: "1:566295949160:web:2edd2bd1c4b74277a5f0dd",
  measurementId: "G-ERXQQKY7HM",
};

// --- Initialize Firebase ---
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);
const storage = getStorage(app);

// --- App state ---
let currentUser = null;
let currentUserRole = "staff";
let currentFolder = null; // folder id (null => root)
let folderListenerUnsub = null;
let fileListenerUnsub = null;
let breadcrumbs = [];
let bulkControls = null;
let activeTab = "files"; // files | recycle | settings
let foldersCache = {}; // local cache keyed by folderId for quick permission check

// --- DOM refs ---
const loginSection = document.getElementById("login-section");
const appSection = document.getElementById("app-section");
const loginForm = document.getElementById("login-form");
const emailInput = document.getElementById("login-email");
const passInput = document.getElementById("login-password");
const loginError = document.getElementById("login-error");
const logoutBtn = document.getElementById("logout-btn");
const folderForm = document.getElementById("folder-form");
const folderInput = document.getElementById("folder-name");
const folderList = document.getElementById("folder-list");
const fileList = document.getElementById("file-list");
const fileInput = document.getElementById("file-input");
const uploadBtn = document.getElementById("upload-btn");
const dropArea = document.getElementById("drop-area");
const toast = document.getElementById("toast");
const folderTitle = document.getElementById("folder-title");
const globalSearch = document.getElementById("global-search");
const tabFiles = document.getElementById("tab-files");
const tabRecycle = document.getElementById("tab-recycle");
const tabSettings = document.getElementById("tab-settings");
const settingsPanel = document.getElementById("settings-panel");
const settingsTheme = document.getElementById("settings-theme");
const settingsEmail = document.getElementById("settings-email");

// --- Utilities ---
function showToast(msg) {
  if (!toast) return;
  toast.textContent = msg;
  toast.style.opacity = "0";
  toast.style.display = "block";
  requestAnimationFrame(() => (toast.style.opacity = "1"));
  setTimeout(() => {
    toast.style.opacity = "0";
    setTimeout(() => (toast.style.display = "none"), 250);
  }, 2200);
}
function formatBytes(bytes) {
  if (!bytes && bytes !== 0) return "0 B";
  const sizes = ["B", "KB", "MB", "GB", "TB"];
  if (bytes === 0) return "0 B";
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  return (bytes / Math.pow(1024, i)).toFixed(1) + " " + sizes[i];
}
function el(tag, cls = "", attrs = {}) {
  const e = document.createElement(tag);
  if (cls) e.className = cls;
  Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
  return e;
}
function safeLog(...a) {
  try {
    console.log(...a);
  } catch (e) {}
}

// --- Role helper: load role from /users/{uid}/role ---
async function loadUserRole(uid) {
  try {
    const snap = await dbGet(ref(db, `users/${uid}/role`));
    if (snap.exists()) {
      return snap.val();
    } else {
      return null;
    }
  } catch (e) {
    console.warn("loadUserRole failed:", e);
    return null;
  }
}

// --- Default folder structure creation ---
async function initDefaultStructureIfNeeded() {
  try {
    const rootSnap = await dbGet(ref(db, "folders"));
    if (rootSnap.exists()) {
      // some folders exist; cache them
      const all = rootSnap.val();
      Object.keys(all).forEach((k) => (foldersCache[k] = all[k]));
      return;
    }
  } catch (e) {
    console.warn("init check failed:", e);
  }

  // create default folders (ids autogenerated)
  const defaultFolders = [
    { key: "administration", name: "Administration", division: "hr", access: { read: { hr: true, ceo: true }, write: { hr: true, ceo: true } } },
    { key: "sales", name: "Sales", division: "sales", access: { read: { sales: true, coo: true }, write: { sales: true, coo: true } } },
    { key: "it_service", name: "IT_Service", division: "it", access: { read: { it: true, cto: true }, write: { it: true, cto: true } } },
    { key: "marketing", name: "Marketing", division: "marketing", access: { read: { marketing: true, cmo: true }, write: { marketing: true, cmo: true } } },
    { key: "finance", name: "Finance", division: "finance", access: { read: { finance: true, cfo: true }, write: { finance: true, cfo: true } } },
    { key: "warehouse", name: "Warehouse", division: "warehouse", access: { read: { warehouse: true, coo: true }, write: { warehouse: true, coo: true } } },
    { key: "shared", name: "Shared", division: "shared", access: { read: { staff: true, hr: true, sales: true, it: true, marketing: true, finance: true, warehouse: true, ceo: true }, write: { ceo: true, admin: true } } },
  ];

  const updates = {};
  defaultFolders.forEach((f) => {
    // store under key names to make predictable IDs (so UI can rely on them)
    updates[`folders/${f.key}`] = {
      name: f.name,
      parentId: null,
      division: f.division,
      access: f.access,
      fileCount: 0,
      createdAt: Date.now(),
    };
  });

  try {
    await update(ref(db), updates);
    // refresh cache
    const snap = await dbGet(ref(db, "folders"));
    if (snap.exists()) {
      const all = snap.val();
      Object.keys(all).forEach((k) => (foldersCache[k] = all[k]));
    }
    showToast("✅ Struktur folder default dibuat");
  } catch (err) {
    console.error("initDefaultStructure failed:", err);
    showToast("Gagal membuat struktur folder default");
  }
}

// --- AUTH FLOW ---
loginForm.addEventListener("submit", async (e) => {
  e.preventDefault();
  loginError.textContent = "";
  const email = emailInput.value.trim();
  const password = passInput.value.trim();
  if (!email) {
    loginError.textContent = "Isi email";
    return;
  }
  try {
    await signInWithEmailAndPassword(auth, email, password);
  } catch (err) {
    loginError.textContent = "Login gagal: " + (err.message || err.code);
  }
});

logoutBtn.addEventListener("click", () => {
  signOut(auth).catch((e) => console.warn("Signout failed:", e));
});

onAuthStateChanged(auth, async (user) => {
  if (user) {
    currentUser = user;
    document.getElementById("user-info").textContent = user.email;
    settingsEmail.value = user.email || "";
    loginSection.style.display = "none";
    appSection.removeAttribute("aria-hidden");

    // 🟢 Tambahan: pastikan user sudah ada di RTDB /users
    const userRef = ref(db, `users/${user.uid}`);
    const userSnap = await dbGet(userRef);
    if (!userSnap.exists()) {
      await set(userRef, {
        email: user.email,
        name: user.displayName || "",
        role: "staff", // default role untuk user baru
        createdAt: Date.now(),
      });
    }

    // load role dari RTDB (ambil dari node user yang baru dibuat juga)
    const role = await loadUserRole(user.uid);
    currentUserRole = role || "staff";

    // pastikan struktur folder default sudah ada
    await initDefaultStructureIfNeeded();

    // set default state UI
    breadcrumbs = [{ id: null, name: "Root" }];
    currentFolder = null;
    activeTab = "files";
    renderBreadcrumbs();
    setActiveTabUI();

    // mulai listener realtime
    loadFoldersRealtime();
    loadFilesRealtime();

  } else {
    // user logout / belum login
    currentUser = null;
    currentUserRole = "staff";
    if (folderListenerUnsub) folderListenerUnsub();
    if (fileListenerUnsub) fileListenerUnsub();
    appSection.setAttribute("aria-hidden", "true");
    loginSection.style.display = "flex";
  }
});

// --- Breadcrumbs ---
function renderBreadcrumbs() {
  let bc = document.getElementById("breadcrumb");
  if (!bc) {
    bc = el("div", "breadcrumbs");
    bc.id = "breadcrumb";
    const filesHeader = document.querySelector(".files-header");
    if (filesHeader && filesHeader.parentNode) {
      filesHeader.parentNode.insertBefore(bc, filesHeader);
    } else {
      const right = document.querySelector(".right-col");
      if (right) right.prepend(bc);
    }
  }
  bc.innerHTML = "";
  breadcrumbs.forEach((b, idx) => {
    const crumb = el("button", "btn crumb");
    crumb.textContent = idx === 0 ? b.name : " / " + b.name;
    crumb.onclick = () => {
      breadcrumbs = breadcrumbs.slice(0, idx + 1);
      const target = b.id || null;
      openFolder(target, b.name);
    };
    bc.appendChild(crumb);
  });
}

// --- Load Folders Realtime (children of currentFolder) ---
function loadFoldersRealtime() {
  if (!currentUser) return;
  // cleanup previous listener
  if (folderListenerUnsub) folderListenerUnsub();

  // Query folders where parentId == currentFolder (using RTDB query)
  const q = query(ref(db, "folders"), orderByChild("parentId"), equalTo(currentFolder || null));
  const listener = onValue(
    q,
    (snapshot) => {
      folderList.innerHTML = "";
      foldersCache = foldersCache || {};
      // snapshot.val() will be object of children or null
      const data = snapshot.val() || {};
      // update cache for these children
      Object.entries(data).forEach(([id, val]) => {
        foldersCache[id] = val;
      });
      // render each folder if user has read access (client-side filter)
      Object.entries(data).forEach(([id, f]) => {
        const canRead = checkFolderReadPermission(f);
        if (!canRead) return; // hide folders not permitted
        const div = el("div", "folder-card");
        div.dataset.id = id;
        div.innerHTML = `
          <span>📁 ${f.name}</span>
          <small class="small-muted">${f.fileCount || 0} file</small>
        `;
        div.onclick = (e) => {
          e.stopPropagation();
          breadcrumbs.push({ id, name: f.name });
          renderBreadcrumbs();
          openFolder(id, f.name);
        };
        div.ondragover = (e) => {
          e.preventDefault();
          div.classList.add("drag-over");
        };
        div.ondragleave = () => div.classList.remove("drag-over");
        div.ondrop = (e) => handleMoveFiles(e, id);
        div.oncontextmenu = async (e) => {
          e.preventDefault();
          // only allow rename if write permission
          if (!checkFolderWritePermission(f)) return showToast("Tidak punya izin mengubah folder");
          const choice = prompt("Rename folder (kosong = batalkan):", f.name);
          if (choice && choice.trim() !== f.name) {
            try {
              await update(ref(db, `folders/${id}`), { name: choice.trim() });
              showToast("✏️ Nama folder diperbarui");
            } catch (err) {
              console.error("Rename folder failed:", err);
              showToast("Gagal mengganti nama folder");
            }
          }
        };
        folderList.appendChild(div);
      });
    },
    (err) => {
      console.warn("folders listener error:", err);
      showToast("Gagal mendapatkan daftar folder");
    }
  );

  // return unsubscribe function
  folderListenerUnsub = () => listener(); // calling returned function detaches
}

// --- Check permissions client-side (basic) ---
function checkFolderReadPermission(folderObj) {
  if (!folderObj) return false;
  if (!currentUser) return false;
  // admin/root quick allow (note: server rules enforce too)
  if (currentUser.email === "root@atlantis.com" || currentUser.email === "admin@atlantis.com") return true;
  const access = folderObj.access || {};
  const readMap = access.read || {};
  // if shared (division == 'shared') OR explicit role true
  if (folderObj.division === "shared") return true;
  if (readMap[currentUserRole]) return true;
  // owner-based? not relevant for folder
  return false;
}
function checkFolderWritePermission(folderObj) {
  if (!folderObj) return false;
  if (!currentUser) return false;
  if (currentUser.email === "root@atlantis.com" || currentUser.email === "admin@atlantis.com") return true;
  const access = folderObj.access || {};
  const writeMap = access.write || {};
  if (writeMap[currentUserRole]) return true;
  return false;
}

// --- Create folder (supports parentId) ---
folderForm.addEventListener("submit", async (e) => {
  e.preventDefault();
  const name = folderInput.value.trim();
  if (!name || !currentUser) return;
  // parentId = currentFolder or null
  const parentId = currentFolder || null;
  // default division = currentUserRole for new folder (you can adjust)
  const division = currentUserRole;
  // read/write defaults: write only by that division and admin/ceo
  const access = {
    read: { [division]: true },
    write: { [division]: true },
  };
  try {
    const newRef = push(ref(db, "folders"));
    await set(newRef, {
      name,
      parentId,
      division,
      access,
      fileCount: 0,
      createdAt: Date.now(),
      localCreatedAt: Date.now(),
    });
    folderInput.value = "";
    showToast("📁 Folder dibuat");
  } catch (err) {
    console.error("Create folder failed:", err);
    showToast("Gagal membuat folder");
  }
});

// --- Open folder: update state + reload children/files ---
async function openFolder(id, name) {
  // if opening Administration folder, show admin user manager (admin only)
  if (id === 'administration') {
    if (currentUser && (currentUserRole === 'admin' || currentUser.email === 'admin@atlantis.com')) {
      breadcrumbs = [{ id: 'administration', name: 'Administration' }];
      renderBreadcrumbs();
        await renderAdminUserPanel();
      currentFolder = id;
      folderTitle.textContent = '👥 Administration - User Management';
      return;
    } else {
      showToast('Tidak punya izin melihat Administration');
      return;
    }
  }
  // --- original logic for other folders ---
  currentFolder = id || null;
  folderTitle.textContent = '📂 ' + (name || 'Root');
  if (dropArea) {
    dropArea.innerHTML = `<p>Tarik & lepas file di sini, atau klik Upload</p><small class="muted">Folder saat ini: ${name || 'Root'}</small>`;
  }
  renderBreadcrumbs();
  loadFoldersRealtime();
  loadFilesRealtime();
}


// --- Admin: render user list and allow role edits (shown when opening 'administration' folder) ---
async function renderAdminUserPanel() {
  if (!currentUser) return showToast("Harap login sebagai admin");
  // clear UI areas
  folderList.innerHTML = "";
  fileList.innerHTML = "";
  // header/title
  folderTitle.textContent = "👥 Administration - Users";
  // fetch all users
  try {
    const usersSnap = await dbGet(ref(db, "users"));
    const users = usersSnap.exists() ? usersSnap.val() : {};
    // render each user as a row in fileList
    Object.entries(users).forEach(([uid, u]) => {
      const li = el("li", "file-row");
      li.dataset.uid = uid;
      li.innerHTML = `
        <div class="file-info">
          <div style="min-width:220px;">
            <strong>${u.email || uid}</strong>
            <div class="file-sub">${u.name || ""} • ${u.createdAt ? new Date(u.createdAt).toLocaleString() : ""}</div>
          </div>
        </div>
        <div class="file-actions">
          <select data-role="${uid}">
            <option value="staff" ${u.role === "staff" ? "selected" : ""}>Staff</option>
            <option value="admin" ${u.role === "admin" ? "selected" : ""}>Admin</option>
            <option value="hr" ${u.role === "hr" ? "selected" : ""}>HR</option>
            <option value="sales" ${u.role === "sales" ? "selected" : ""}>Sales</option>
            <option value="it" ${u.role === "it" ? "selected" : ""}>IT</option>
            <option value="marketing" ${u.role === "marketing" ? "selected" : ""}>Marketing</option>
            <option value="finance" ${u.role === "finance" ? "selected" : ""}>Finance</option>
            <option value="warehouse" ${u.role === "warehouse" ? "selected" : ""}>Warehouse</option>
          </select>
          <button class="btn danger" data-remove="${uid}" title="Delete user">🗑️</button>
        </div>
      `;
      fileList.appendChild(li);
    });

    // attach handlers for role change
    fileList.querySelectorAll("select[data-role]").forEach((sel) => {
      sel.onchange = async (e) => {
        const uid = sel.getAttribute("data-role");
        const newRole = sel.value;
        try {
          await update(ref(db, `users/${uid}`), { role: newRole });
          showToast(`Role diperbarui: ${newRole}`);
          // if we changed ourselves, update local role
          if (uid === currentUser.uid) currentUserRole = newRole;
        } catch (err) {
          console.error("Update role failed:", err);
          showToast("Gagal memperbarui role");
        }
      };
    });

    // attach handlers for remove (careful: this only removes user node, not auth)
    fileList.querySelectorAll("button[data-remove]").forEach((btn) => {
      btn.onclick = async (e) => {
        const uid = btn.getAttribute("data-remove");
        if (!confirm("Hapus node user ini dari RTDB? (tidak menghapus akun Auth)")) return;
        try {
          await remove(ref(db, `users/${uid}`));
          showToast("User dihapus dari RTDB");
          // re-render
          renderAdminUserPanel();
        } catch (err) {
          console.error("Remove user node failed:", err);
          showToast("Gagal menghapus user");
        }
      };
    });
  } catch (err) {
    console.error("renderAdminUserPanel failed:", err);
    showToast("Gagal memuat daftar user");
  }
}
// --- Files realtime (per currentFolder) ---
function loadFilesRealtime() {
  if (!currentUser) return;
  if (fileListenerUnsub) fileListenerUnsub();

  // first, read folder metadata (to determine access rules)
  const folderRefPath = currentFolder ? `folders/${currentFolder}` : null;
  dbGet(ref(db, folderRefPath || "folders")).then(async (folderSnap) => {
    // fetch files where folderId == currentFolder (note: RTDB doesn't index keys automatically —
    // ensure you've configured indexes if needed in console)
    const filesQuery = query(ref(db, "files"), orderByChild("folderId"), equalTo(currentFolder || null));
    const listener = onValue(
      filesQuery,
      (snapshot) => {
        fileList.innerHTML = "";
        const filesObj = snapshot.val() || {};
        // render each file if permitted (owner or folder read permission)
        Object.entries(filesObj).forEach(([id, f]) => {
          // skip deleted for files tab
          if (f.deleted) return;
          // determine folder metadata
          const folderMeta = currentFolder ? foldersCache[currentFolder] || (folderSnap.exists() ? folderSnap.val() : null) : null;
          const allowed = checkFileReadPermission(f, folderMeta);
          if (!allowed) return;
          const li = el("li", "file-row");
          li.dataset.id = id;
          li.draggable = true;
          const created = f.createdAt ? new Date(f.createdAt).toLocaleString() : "baru";
          li.innerHTML = `
            <div class="file-info">
              <input type="checkbox" class="file-checkbox" data-id="${id}" />
              <div class="file-meta" style="margin-left:8px;">
                <span class="file-name">${f.name}</span>
                <span class="file-sub">${formatBytes(f.size||0)} • ${created}</span>
              </div>
            </div>
            <div class="file-actions">
              <button class="btn" data-preview="${f.url}">👁️</button>
              <button class="btn danger" data-delete="${id}" data-path="${f.storagePath}">🗑️</button>
            </div>
          `;
          li.ondragstart = (e) => {
            e.dataTransfer.setData("text/plain", id);
          };
          fileList.appendChild(li);
        });
        attachFileRowHandlers();
      },
      (err) => {
        console.warn("files listener error:", err);
        showToast("Gagal mendapatkan daftar file");
      }
    );
    fileListenerUnsub = () => listener();
  });
}

// --- Check file read/write permission client-side ---
function checkFileReadPermission(fileObj, folderMeta) {
  if (!currentUser) return false;
  if (!fileObj) return false;
  // admin quick allow
  if (currentUser.email === "root@atlantis.com" || currentUser.email === "admin@atlantis.com") return true;
  if (fileObj.owner === currentUser.email) return true;
  // if folderMeta says shared or read map includes role
  const folder = folderMeta || (fileObj.folderId ? foldersCache[fileObj.folderId] : null);
  if (!folder) return false;
  if (folder.division === "shared") return true;
  const readMap = (folder.access && folder.access.read) || {};
  if (readMap[currentUserRole]) return true;
  return false;
}
function checkFileWritePermission(fileObj, folderMeta) {
  if (!currentUser) return false;
  if (!fileObj) return false;
  if (currentUser.email === "root@atlantis.com" || currentUser.email === "admin@atlantis.com") return true;
  const folder = folderMeta || (fileObj.folderId ? foldersCache[fileObj.folderId] : null);
  if (!folder) return false;
  const writeMap = (folder.access && folder.access.write) || {};
  if (writeMap[currentUserRole]) return true;
  // owner can update own file metadata (but not move to restricted folder)
  if (fileObj.owner === currentUser.email) return true;
  return false;
}

// --- File row handlers (preview, delete, checkboxes) ---
function attachFileRowHandlers() {
  // preview
  fileList.querySelectorAll("button[data-preview]").forEach((btn) => {
    btn.onclick = (e) => {
      const url = btn.getAttribute("data-preview");
      if (url) previewFile(url);
    };
  });
  // delete (soft-delete -> move to recycle)
  fileList.querySelectorAll("button[data-delete]").forEach((btn) => {
    btn.onclick = async (e) => {
      const id = btn.getAttribute("data-delete");
      if (!id) return;
      if (!confirm("Hapus file ini? File akan dipindahkan ke Recycle Bin.")) return;
      try {
        // mark deleted = true and set deletedAt
        await update(ref(db, `files/${id}`), { deleted: true, deletedAt: Date.now() });
        // decrement folder fileCount transactionally if had folderId
        try {
          const fSnap = await dbGet(ref(db, `files/${id}`));
          const fdata = fSnap.exists() ? fSnap.val() : null;
          if (fdata?.folderId) {
            const folderRef = ref(db, `folders/${fdata.folderId}/fileCount`);
            await runTransaction(folderRef, (cur) => {
              return (cur || 0) > 0 ? (cur - 1) : 0;
            });
          }
        } catch (txErr) {
          console.warn("Adjust folder fileCount failed:", txErr);
        }
        showToast("🗑️ File dipindahkan ke Recycle Bin");
      } catch (err) {
        console.error("Soft-delete failed:", err);
        showToast("Gagal memindahkan file ke Recycle Bin");
      }
    };
  });
  // checkboxes
  fileList.querySelectorAll(".file-checkbox").forEach((cb) => {
    cb.onchange = updateBulkSelectionUI;
  });
}

// --- BULK UI & actions ---
function ensureBulkControls() {
  if (bulkControls) return;
  bulkControls = el("div", "bulk-controls");
  bulkControls.id = "bulk-controls";
  bulkControls.innerHTML = `
    <button id="bulk-download" class="btn">⬇️ Download selected</button>
    <button id="bulk-delete" class="btn danger">🗑️ Delete selected</button>
    <button id="clear-selection" class="btn">✖ Clear</button>
  `;
  document.body.appendChild(bulkControls);
  bulkControls.querySelector("#clear-selection").onclick = () => {
    fileList.querySelectorAll(".file-checkbox").forEach((cb) => (cb.checked = false));
    updateBulkSelectionUI();
  };
  bulkControls.querySelector("#bulk-delete").onclick = bulkDeleteSelected;
  bulkControls.querySelector("#bulk-download").onclick = bulkDownloadSelected;
  updateBulkSelectionUI();
}

function updateBulkSelectionUI() {
  const selected = Array.from(fileList.querySelectorAll(".file-checkbox:checked"));
  if (!bulkControls) return;
  bulkControls.style.display = selected.length > 0 ? "block" : "none";
  bulkControls.querySelector("#bulk-download").textContent = `⬇️ Download (${selected.length})`;
  bulkControls.querySelector("#bulk-delete").textContent = `🗑️ Delete (${selected.length})`;
}

async function bulkDeleteSelected() {
  const selected = Array.from(fileList.querySelectorAll(".file-checkbox:checked")).map((c) => c.dataset.id);
  if (selected.length === 0) return showToast("Pilih file dulu");
  if (!confirm(`Hapus ${selected.length} file? File akan dipindahkan ke Recycle Bin.`)) return;
  for (const id of selected) {
    try {
      await update(ref(db, `files/${id}`), { deleted: true, deletedAt: Date.now() });
    } catch (err) {
      console.error("Bulk soft-delete error:", err);
    }
  }
  showToast("🗑️ Beberapa file dipindahkan ke Recycle Bin");
}

async function bulkDownloadSelected() {
  const selected = Array.from(fileList.querySelectorAll(".file-checkbox:checked")).map((c) => c.dataset.id);
  if (selected.length === 0) return showToast("Pilih file dulu");
  showToast("Membuka file di tab baru untuk download...");
  for (const id of selected) {
    try {
      const fdSnap = await dbGet(ref(db, `files/${id}`));
      const data = fdSnap.exists() ? fdSnap.val() : null;
      if (data?.url) window.open(data.url, "_blank");
    } catch (err) {
      console.warn("Open file failed:", err);
    }
  }
}

// --- Upload handling (Storage unchanged) ---
let globalProgressEl = null;
function ensureGlobalProgress() {
  if (globalProgressEl) return;
  globalProgressEl = el("div", "global-progress");
  globalProgressEl.style.position = "fixed";
  globalProgressEl.style.left = "20px";
  globalProgressEl.style.bottom = "140px";
  globalProgressEl.style.background = "rgba(0,0,0,0.6)";
  globalProgressEl.style.color = "#fff";
  globalProgressEl.style.padding = "8px 12px";
  globalProgressEl.style.borderRadius = "10px";
  globalProgressEl.style.display = "none";
  document.body.appendChild(globalProgressEl);
}
function showGlobalProgress(msg) {
  ensureGlobalProgress();
  globalProgressEl.textContent = msg;
  globalProgressEl.style.display = "block";
}
function hideGlobalProgress() {
  if (!globalProgressEl) return;
  globalProgressEl.style.display = "none";
}

uploadBtn.onclick = () => fileInput.click();
fileInput.onchange = (e) => handleFilesUpload(e.target.files);

dropArea.ondragover = (e) => {
  e.preventDefault();
  dropArea.classList.add("dragover");
};
dropArea.ondragleave = () => dropArea.classList.remove("dragover");
dropArea.ondrop = (e) => {
  e.preventDefault();
  dropArea.classList.remove("dragover");
  handleFilesUpload(e.dataTransfer.files);
};

function handleFilesUpload(files) {
  if (!currentUser) return showToast("Harap login dulu");
  const arr = [...files];
  if (arr.length === 0) return;
  showGlobalProgress(`Uploading ${arr.length} file(s)...`);
  let completed = 0;
  arr.forEach((file) => {
    const path = `${currentUser.uid}/${currentFolder || "root"}/${Date.now()}_${file.name}`;
    const sRef = storageRef(storage, path);
    const task = uploadBytesResumable(sRef, file);
    task.on(
      "state_changed",
      (snap) => {
        const percent = Math.round((snap.bytesTransferred / snap.totalBytes) * 100);
        showGlobalProgress(`⬆️ ${file.name} — ${percent}%`);
      },
      (err) => {
        console.error("Upload failed:", err);
        showToast("Upload gagal: " + (err.message || err.code));
      },
      async () => {
        try {
          const url = await getDownloadURL(task.snapshot.ref);
          const newFileRef = push(ref(db, "files"));
          const metadata = {
            name: file.name,
            size: file.size,
            folderId: currentFolder || null,
            owner: currentUser.email,
            storagePath: path,
            url,
            createdAt: Date.now(),
            localCreatedAt: Date.now(),
            deleted: false,
          };
          await set(newFileRef, metadata);
          // increment folder fileCount safely
          try {
            if (currentFolder) {
              const folderFileCountRef = ref(db, `folders/${currentFolder}/fileCount`);
              await runTransaction(folderFileCountRef, (cur) => {
                return (cur || 0) + 1;
              });
            }
          } catch (e) {
            console.warn("Folder fileCount increment failed:", e);
          }
          completed++;
          if (completed === arr.length) {
            showToast("✅ Semua upload selesai");
            hideGlobalProgress();
          }
        } catch (err) {
          console.error("Finalize upload failed:", err);
          showToast("Gagal menyelesaikan upload");
          hideGlobalProgress();
        }
      }
    );
  });
}

// --- Move file by drag/drop into folder ---
async function handleMoveFiles(e, targetFolderId) {
  e.preventDefault();
  const fileId = e.dataTransfer.getData("text/plain");
  if (!fileId) return;
  try {
    const fSnap = await dbGet(ref(db, `files/${fileId}`));
    const fdata = fSnap.exists() ? fSnap.val() : null;
    if (!fdata) return;
    const srcFolder = fdata.folderId || null;
    if (srcFolder === targetFolderId) {
      showToast("File sudah berada di folder tersebut");
      return;
    }

    // check permission: user must have write on target folder
    const targetFolderSnap = await dbGet(ref(db, `folders/${targetFolderId}`));
    const targetMeta = targetFolderSnap.exists() ? targetFolderSnap.val() : null;
    if (!checkFolderWritePermission(targetMeta)) {
      return showToast("Tidak punya izin menaruh file di folder tersebut");
    }

    // update file.folderId
    await update(ref(db, `files/${fileId}`), { folderId: targetFolderId });

    // adjust counts
    try {
      if (srcFolder) {
        const srcRef = ref(db, `folders/${srcFolder}/fileCount`);
        await runTransaction(srcRef, (cur) => {
          return (cur || 0) > 0 ? (cur - 1) : 0;
        });
      }
      if (targetFolderId) {
        const tgtRef = ref(db, `folders/${targetFolderId}/fileCount`);
        await runTransaction(tgtRef, (cur) => {
          return (cur || 0) + 1;
        });
      }
    } catch (e) {
      console.warn("Adjust folder counts after move failed:", e);
    }

    showToast("📦 File dipindahkan");
  } catch (err) {
    console.error("Move failed:", err);
    showToast("Gagal memindahkan file");
  }
}

// --- Preview ---
window.previewFile = (url) => {
  const modal = document.getElementById("preview-modal");
  const body = document.getElementById("preview-body");
  const download = document.getElementById("preview-download");
  body.innerHTML = `<iframe src="${url}" width="100%" height="600" style="border:0;border-radius:8px;"></iframe>`;
  download.href = url;
  modal.setAttribute("aria-hidden", "false");
};
document.getElementById("close-preview").onclick = () =>
  document.getElementById("preview-modal").setAttribute("aria-hidden", "true");

// --- SEARCH (debounced client-side) ---
let searchTimer = null;
globalSearch.addEventListener("input", () => {
  clearTimeout(searchTimer);
  searchTimer = setTimeout(() => {
    const term = globalSearch.value.trim().toLowerCase();
    if (!term) {
      Array.from(fileList.children).forEach((li) => (li.style.display = ""));
      return;
    }
    Array.from(fileList.children).forEach((li) => {
      const name = (li.querySelector(".file-name")?.textContent || "").toLowerCase();
      li.style.display = name.includes(term) ? "" : "none";
    });
  }, 220);
});

// --- Keyboard shortcut: Ctrl/Cmd+K focus search ---
document.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "k") {
    e.preventDefault();
    globalSearch.focus();
  }
});

// --- Theme handling ---
const themeBtn = document.getElementById("toggle-theme");
themeBtn.onclick = () => {
  const cur = document.documentElement.dataset.theme;
  const next = cur === "dark" ? "light" : "dark";
  document.documentElement.dataset.theme = next;
  localStorage.setItem("theme", next);
  if (settingsTheme) settingsTheme.value = next;
};
document.documentElement.dataset.theme =
  localStorage.getItem("theme") ||
  (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");
if (settingsTheme) settingsTheme.value = document.documentElement.dataset.theme;
settingsTheme?.addEventListener("change", (e) => {
  const v = e.target.value;
  if (v === "auto") {
    const auto = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    document.documentElement.dataset.theme = auto;
    localStorage.setItem("theme", auto);
  } else {
    document.documentElement.dataset.theme = v;
    localStorage.setItem("theme", v);
  }
});

// --- Tabs: Files / Recycle / Settings ---
function setActiveTabUI() {
  tabFiles.classList.toggle("active", activeTab === "files");
  tabRecycle.classList.toggle("active", activeTab === "recycle");
  tabSettings.classList.toggle("active", activeTab === "settings");

  const content = document.querySelector(".content");
  if (content) content.style.display = activeTab === "files" ? "flex" : "none";
  settingsPanel.setAttribute("aria-hidden", activeTab === "settings" ? "false" : "true");

  if (activeTab === "files") {
    loadFoldersRealtime();
    loadFilesRealtime();
  } else if (activeTab === "recycle") {
    loadRecycleBin();
  } else if (activeTab === "settings") {
    // nothing extra
  }
}
tabFiles.onclick = () => { activeTab = "files"; setActiveTabUI(); };
tabRecycle.onclick = () => { activeTab = "recycle"; setActiveTabUI(); };
tabSettings.onclick = () => { activeTab = "settings"; setActiveTabUI(); };

// --- Recycle Bin: realtime view of deleted files ---
function loadRecycleBin() {
  if (!currentUser) return;
  if (fileListenerUnsub) fileListenerUnsub();
  const q = query(ref(db, "files"), orderByChild("deleted"), equalTo(true));
  const listener = onValue(q, (snapshot) => {
    fileList.innerHTML = "";
    const filesObj = snapshot.val() || {};
    Object.entries(filesObj).forEach(([id, f]) => {
      const li = el("li", "file-row");
      li.innerHTML = `
        <div class="file-info">
          🗑️ <span class="file-name">${f.name}</span>
          <div class="file-sub">${formatBytes(f.size)} • ${f.deletedAt ? new Date(f.deletedAt).toLocaleString() : "baru"}</div>
        </div>
        <div class="file-actions">
          <button class="btn" data-restore="${id}">♻️ Restore</button>
          <button class="btn danger" data-permadelete="${id}" data-path="${f.storagePath}">❌ Hapus Permanen</button>
        </div>
      `;
      fileList.appendChild(li);
    });

    // attach restore / permanent delete handlers
    fileList.querySelectorAll("button[data-restore]").forEach((btn) => {
      btn.onclick = async () => {
        const id = btn.getAttribute("data-restore");
        if (!id) return;
        try {
          await update(ref(db, `files/${id}`), { deleted: false, deletedAt: null });
          // increment folder count if file had folderId
          try {
            const fd = await dbGet(ref(db, `files/${id}`));
            const data = fd.exists() ? fd.val() : null;
            if (data?.folderId) {
              const folderRef = ref(db, `folders/${data.folderId}/fileCount`);
              await runTransaction(folderRef, (cur) => {
                return (cur || 0) + 1;
              });
            }
          } catch (e) {
            console.warn("Restore: increment folder failed", e);
          }
          showToast("♻️ Dipulihkan");
        } catch (err) {
          console.error("Restore failed:", err);
          showToast("Gagal memulihkan file");
        }
      };
    });

    fileList.querySelectorAll("button[data-permadelete]").forEach((btn) => {
      btn.onclick = async () => {
        const id = btn.getAttribute("data-permadelete");
        const path = btn.getAttribute("data-path");
        if (!id) return;
        if (!confirm("Hapus permanen file ini? Tindakan ini tidak bisa dibatalkan.")) return;
        try {
          await remove(ref(db, `files/${id}`));
          if (path) {
            await deleteObject(storageRef(storage, path)).catch((e) => console.warn("Storage delete:", e));
          }
          showToast("❌ File dihapus permanen");
        } catch (err) {
          console.error("Permanent delete failed:", err);
          showToast("Gagal menghapus file permanen");
        }
      };
    });
  }, (err) => {
    console.warn("recycle listener error:", err);
    showToast("Gagal memuat Recycle Bin");
  });

  fileListenerUnsub = () => listener();
}

// --- Initial bootstrap & UI polish ---
(function init() {
  breadcrumbs = [{ id: null, name: "Root" }];
  renderBreadcrumbs();
  dropArea.innerHTML = `<p>Tarik & lepas file di sini, atau klik Upload</p><small class="muted">Folder saat ini: Root</small>`;
  showToast("Atlantis NAS (RTDB) siap");
  ensureBulkControls();
})();

safeLog("Atlantis NAS RTDB app.js loaded");



